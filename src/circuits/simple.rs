use std::marker::PhantomData;

use eth_types::Field;
use halo2_proofs::{plonk::{Column, Advice, Instance, Selector, ConstraintSystem, Fixed}, circuit::Chip, poly::Rotation};



/// This chip will implement our instructions! Chips store their own
/// config, as well as type markers if necessary.
struct FieldChip<F: Field> {
    config: FieldConfig,
    _marker: PhantomData<F>,
}

/// Chip state is stored in a config struct. This is generated by the chip
/// during configuration, and then stored inside the chip.
#[derive(Clone, Debug)]
pub struct FieldConfig {
    /// For this chip, we will use two advice columns to implement our instructions.
    /// These are also the columns through which we communicate with other parts of
    /// the circuits.
    advice: [Column<Advice>; 2],

    /// This is the public input (instance) column.
    instance: Column<Instance>,

    constant: Column<Fixed>,

    /// We need a selector to enable the multiplication gate, so that we aren't placing
    /// any constraints on cells where `NumericInstructions::mul` is not being used.
    /// This is important when building larger circuits, where columns are used by
    /// multiple sets of instructions.
    s_mul: Selector,
}

impl<F: Field> Chip<F> for FieldChip<F> {
    type Config = FieldConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}

impl<F: Field> FieldChip<F> {
    fn configure(meta: &mut ConstraintSystem<F>, advice: [Column<Advice>; 2], instance: Column<Instance>, constant: Column<Fixed>,) -> <Self as Chip<F>>::Config {
        meta.enable_equality(instance);
        meta.enable_constant(constant);
        for column in &advice {
            meta.enable_equality(*column);
        }
        let s_mul = meta.selector();

        meta.create_gate("mul", |meta| {
            let s_mul = meta.query_selector(s_mul);

            let a = meta.query_advice(advice[0], Rotation::cur());
            let b = meta.query_advice(advice[1], Rotation::cur());
            let c = meta.query_fixed(constant, Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            vec![s_mul * (a.clone() * a * b.clone() * b * c - out)] 
        });

        FieldConfig {
            advice,
            instance,
            constant,
            s_mul,
        }
    }
}

#[cfg(test)]
mod tests {
    use std::marker::PhantomData;

    use eth_types::Field;
    use halo2_proofs::{
        circuit::{Layouter, SimpleFloorPlanner, Value},
        dev::MockProver,
        halo2curves::bn256::Fr as Fp,
        plonk::{Circuit, ConstraintSystem, Error},
    };
    
    use super::{FieldConfig, FieldChip};

    #[derive(Default)]
    struct TestCircuit<F: Field> {
        pub a: Value<F>,
        pub b: Value<F>,
        pub constant: F,
        _marker: PhantomData<F>,
    }

    impl<F: Field> Circuit<F> for TestCircuit<F> {
        type Config = FieldConfig;
        type FloorPlanner = SimpleFloorPlanner;
        #[cfg(feature = "circuit-params")]
        type Params = ();

        fn without_witnesses(&self) -> Self {
            Self::default()
        }

        fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
            let advice = [meta.advice_column(), meta.advice_column()];
            let instance = meta.instance_column();
            let constant = meta.fixed_column();

            FieldChip::configure(meta, advice, instance, constant)
        }

        fn synthesize(&self, config: Self::Config, mut layouter: impl Layouter<F>) -> Result<(), Error> {

            let out = layouter.assign_region(
                || "witness",
                |mut region| {
                    let _ = config.s_mul.enable(&mut region, 0);
                    
                    region.assign_advice(|| "a", config.advice[0], 0, || self.a)?;
                    region.assign_advice(|| "b", config.advice[1], 0, || self.b)?;
                    region.assign_fixed(|| "c", config.constant, 0, || Value::<F>::known(self.constant))?;

                    region.assign_advice(|| "out", config.advice[0], 
                        1, || self.a.clone() * self.a * self.b.clone() * self.b * Value::<F>::known(self.constant))
                },
            )?;

            layouter
                .namespace(|| "out")
                .constrain_instance(out.cell(), config.instance, 0)

        }

    }

    macro_rules! try_test {
        ($a:expr, $b:expr, $c:expr, $i:expr, $is_ok_or_err:ident) => {
            let circuit = TestCircuit::<Fp> {
                a: $a,
                b: $b,
                constant: $c,
                _marker: PhantomData,
            };
            let prover = MockProver::<Fp>::run(4, &circuit, vec![$i]).unwrap();
            assert!(prover.verify().$is_ok_or_err());
        };
    }

    #[test]
    fn is_equal_gadget() {
        try_test!(
            Value::known(Fp::from(2)),
            Value::known(Fp::from(2)),
            Fp::from(2),
            vec![Fp::from(2).square() * Fp::from(2).square() * Fp::from(2)],
            is_ok
        );
        try_test!(
            Value::known(Fp::from(3)),
            Value::known(Fp::from(5)),
            Fp::from(4),
            vec![Fp::from(3).square() * Fp::from(5).square() * Fp::from(4)],
            is_ok
        );
        try_test!(
            Value::known(Fp::from(2)),
            Value::known(Fp::from(3)),
            Fp::from(5),
            vec![Fp::from(2).square() * Fp::from(2).square() * Fp::from(5)],
            is_err
        );
    }
}